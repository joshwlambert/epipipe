[{"path":"https://joshwlambert.github.io/epipipe/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 epipipe authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"step-2-line-list-aggregation","dir":"Articles","previous_headings":"","what":"Step 2: Line list aggregation","title":"linelist_aggregation","text":"report explains necessary data preparation processes importing line list data frame. Input Case data line list format (cases_clean.rds) produced previous step (link). output Case incidence grouped time interval (cases.rds)","code":""},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"loading-libraries","dir":"Articles","previous_headings":"Step 2: Line list aggregation","what":"Loading libraries","title":"linelist_aggregation","text":"following code loads required packages; missing packages installed automatically, require working internet connection installation successful.","code":"library(dplyr) # For data wrangling library(incidence2) # For generating incidence data"},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"input-data","dir":"Articles","previous_headings":"Step 2: Line list aggregation","what":"Input data","title":"linelist_aggregation","text":"example, use line list data extracted Go.Data API. example data set already cleaned, important make sure applied necessary data cleaning steps : Column names cleaned standardized Data types properly assigned Missing / duplicated values treated Categorical values cleaned","code":"# Go.Data extract as an example cases_clean <- readRDS(file.path(\"inst\", \"extdata\", \"godata_exports\", \"cases_clean.rds\"))  head(cases_clean)"},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"format-the-date-columns-properly","dir":"Articles","previous_headings":"Step 2: Line list aggregation","what":"Format the date columns properly","title":"linelist_aggregation","text":"need one date index column produce aggregated incidence output. optional, example, since nrow(cases_clean[.na(cases_clean$date_of_onset),]) nrow(cases_clean) cases without date_of_osnet values, compliment date_of_reporting value.","code":"cases_clean <- cases_clean %>%   mutate(     date_of_onset = case_when(       is.na(date_of_onset) ~ date_of_reporting,       TRUE ~ date_of_onset)   )"},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"apply-necessary-aggregation-and-rename","dir":"Articles","previous_headings":"Step 2: Line list aggregation","what":"Apply necessary aggregation and rename","title":"linelist_aggregation","text":"convert time-indexed grouped data frame three columns: date_index - time index analysis (eg. date infection, onset symptoms, reporting…) group - grouping variable might need (eg. places, age groups) count - Counts observations per time group two ways achieving step follows.","code":""},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"option-1-using-incidence-function-from-the-incidence2-package-","dir":"Articles","previous_headings":"Step 2: Line list aggregation > Apply necessary aggregation and rename","what":"Option 1: Using incidence() function from the incidence2 package.","title":"linelist_aggregation","text":"method, output incidence2 class object. , can also simply plot incidence data. See information incidence2 package .","code":"# Generate the incidence object cases <- incidence(cases_clean %>% filter(!is.na(admin_1_name)),                     groups = \"admin_1_name\",                     date_index = \"date_of_onset\")    # Rename necessary columns cases <- cases %>%   rename(group = admin_1_name)   head(cases) plot(cases)"},{"path":"https://joshwlambert.github.io/epipipe/articles/B.1_linelist_aggregation.html","id":"option-2-using-group_by-function-from-the-dplyr-package-","dir":"Articles","previous_headings":"Step 2: Line list aggregation > Apply necessary aggregation and rename","what":"Option 2: Using group_by() function from the dplyr package.","title":"linelist_aggregation","text":"method, output data frame object.","code":"cases <- cases_clean %>% filter(!is.na(admin_1_name)) %>%   group_by(date_index=date_of_onset, group=admin_1_name) %>%   summarise(count = n())  head(cases)"},{"path":[]},{"path":"https://joshwlambert.github.io/epipipe/articles/Rt_EpiEstim.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Rt_EpiEstim","text":"","code":"# Function to process output from `EpiEstim::estimate_R` and output a tibble # with dates, mean R, and 95% credible intervals #' #' @param x An `estimate_R` object #' @param incid (Optional) The incidence2 object on which R values have been #'   estimated. wrap_res <- function(x, incid = NULL) {   stopifnot(inherits(x, \"estimate_R\"))   out <- tibble::tibble(x$R)   out <- dplyr::select(out,     start = t_start,     end = t_end,     mean = `Mean(R)`,     sd = `Std(R)`,     median = `Median(R)`,     lower = `Quantile.0.025(R)`,     upper = `Quantile.0.975(R)`   )   if (!is.null(incid)) {     stopifnot(inherits(incid, \"incidence2\"))     dates <- unique(incidence2::get_dates(incid))     out$start <- dates[out$start]     out$end <- dates[out$end]   }    class(out) <- c(\"R_estimate\", class(out))   out }"},{"path":"https://joshwlambert.github.io/epipipe/articles/Rt_EpiEstim.html","id":"serial-interval-settings","dir":"Articles","previous_headings":"Results","what":"Serial interval settings","title":"Rt_EpiEstim","text":"setup serial interval settings EpiEstim use, assume mean 4.2 standard deviation 4.9, using \"parametric_si\" method EpiEstim.","code":"# Run EpiEstim config_epiestim <- EpiEstim::make_config(mean_si = 4.2,                                          std_si = 4.9)"},{"path":"https://joshwlambert.github.io/epipipe/articles/Rt_EpiEstim.html","id":"global-transmissibility","dir":"Articles","previous_headings":"Results","what":"Global transmissibility","title":"Rt_EpiEstim","text":"analyses present results global incidence, .e. without stratification. Results include: now use EpiEstim estimate Rt global incidence, .e. without stratification. default estimated weekly sliding windows. plot Rt, showing median dark green line 95% credible interval represented pale green area. Values plotted end date weekly sliding windows. output table giving mean, median 95% credible intervals, reporting end date weekly sliding window.","code":"res_epiestim_global <- cases_clean |>   incidence2::regroup() |>   incidence2::get_count_value() |>   EpiEstim::estimate_R(method = \"parametric_si\",                        config = config_epiestim) |>   wrap_res(cases_clean) # Graph of all values over time ggplot(res_epiestim_global, aes(x = end)) +   geom_ribbon(aes(ymin = lower, ymax = upper), fill = pale_green) +   geom_line(aes(y = median), color = dark_green) +   geom_hline(yintercept = 1, color = dark_pink) +   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +   labs(     x = \"\",     y = \"Instantaneous reproduction number (Rt)\",     title = \"Estimates of Rt (EpiEstim)\"   ) # Table res_epiestim_global |>   tail(params$r_estim_window) |>   dplyr::mutate(     date = end,     mean = round(mean, 2),     median = round(median, 2),     `95% ci` = sprintf(       \"[%1.2f ; %1.2f]\",       lower,       upper     )   ) |>   dplyr::select(date, mean, median, `95% ci`) |>   dplyr::rename(     \"mean $R$\" = mean,     \"median $R$\" = median   ) |>   purrr::set_names(toupper) |>   kableExtra::kbl() |>   kableExtra::kable_paper(\"striped\", font_size = 18, full_width = FALSE)"},{"path":"https://joshwlambert.github.io/epipipe/articles/Rt_EpiEstim.html","id":"transmissibility-by-group","dir":"Articles","previous_headings":"Results","what":"Transmissibility by group","title":"Rt_EpiEstim","text":"now run EpiEstim estimate Rt , time keep data stratified groups calculate Rt group based incidence group. plot Rt group, showing median dark green line 95% credible interval represented pale green area. Values plotted end date weekly sliding windows. produce whiskers plot latest estimate Rt (.e. final weekly rolling window) region, dots representing median whiskers 95% credible intervals. Now present estimates Rt region final weekly rolling window table, giving mean, median 95% credible interval.","code":"res_epiestim_group <- cases_clean |>   tidyr::nest(data = c(incidence2::get_date_index_name(.),                        incidence2::get_count_value_name(.))) |>   dplyr::mutate(     res_epiestim = map(data, ~ wrap_res(       EpiEstim::estimate_R(.x$count,                            method = \"parametric_si\",                            config = config_epiestim),       cases_clean)     )   ) |>   tidyr::unnest(res_epiestim) |>   dplyr::select(-data) # Graph of all values over time ggplot(res_epiestim_group, aes(x = end)) +   geom_ribbon(aes(ymin = lower, ymax = upper), fill = pale_green) +   geom_line(aes(y = median), color = dark_green) +   geom_hline(yintercept = 1, color = dark_pink) +   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +   facet_wrap(~ .data[[group_var]], ncol = 1) +   labs(     x = \"\",     y = \"Instantaneous reproduction number (Rt)\",     title = \"Estimates of Rt (EpiEstim)\"   ) # Plot of latest estimates res_epiestim_group |>   dplyr::filter(end == max(end)) |>   ggplot(aes(y = .data[[group_var]]), fill = custom_grey) +     geom_point(aes(x = median), color = dark_green) +     geom_errorbar(aes(xmin = lower, xmax = upper), color = dark_green) +     geom_vline(xintercept = 1, color = dark_pink) +     labs(       title = \"Latest estimates of Rt\",       subtitle = sprintf(         \"As of %s\",         format(max(get_dates(cases_clean)), \"%d %B %Y\")       ),       y = \"\",       x = \"Instantaneous Reproduction Number (Rt)\"     ) res_epiestim_group |>   dplyr::filter(end == max(end)) |>   dplyr::mutate(     mean = round(mean, 2),     median = round(median, 2),     `95% ci` = sprintf(       \"[%1.2f ; %1.2f]\",       lower,       upper     )   ) |>   dplyr::select(-c(sd, lower, upper, count_variable)) |>   dplyr::rename(     \"mean $R$\" = mean,     \"median $R$\" = median   ) %>%   purrr::set_names(toupper) |>   kableExtra::kbl() |>   kableExtra::kable_paper(\"striped\", font_size = 18, full_width = FALSE)"},{"path":"https://joshwlambert.github.io/epipipe/articles/linelist_import.html","id":"option-1--locally-stored-excel","dir":"Articles","previous_headings":"","what":"Option 1. locally stored excel","title":"Linelist Data Import","text":"","code":"# import linelist <- import(here(\"data\",\"MSF_linelist.xlsx\"))  # rename df and vars"},{"path":"https://joshwlambert.github.io/epipipe/articles/linelist_import.html","id":"option-2--godata-via-godatar","dir":"Articles","previous_headings":"","what":"Option 2. godata via godataR","title":"Linelist Data Import","text":"","code":"# Install godataR package devtools::install_github(\"WorldHealthOrganization/godataR\") library(godataR) library(getPass) # Set Go.Data login credentials:  ## Your Go.Data URL ## this should match whatever is the your Go.Data URL. the below a URL to a demo instance with fake data. url <- \"https://godata-r19.who.int/\"    ## Your email address to log in to Go.Data  username <- getPass::getPass(msg = \"Enter your Go.Data username (email address):\")  ## you can use testuser7@who.int  # Your password to log in to Go.Data ## a pop-up box will appear for you to enter your pw password <- getPass::getPass(msg = \"Enter your Go.Data password:\")  ## you can use godatatrombonestaple   # Get and clean case data from Go.Data API  # within outbreak API endpoint so this also requires getting active outbreak ID for disease of interest # a few other cleaning steps that are a natural next step after data extraction   # Get ID for active outbreak: outbreak_id <- godataR::get_active_outbreak(url = url,                                              username = username,                                              password = password)  cases <- get_cases(   url = url,   username = username,   password = password,   outbreak_id = outbreak_id)  language_tokens <- get_language_tokens(   url = url,   username = username,   password = password,   language = \"english_us\")  locations <- get_locations(   url = url,   username = username,   password = password)  locations_clean <- clean_locations(                         locations = locations,                         language_tokens = language_tokens)  # other cleaned data required for `clean_cases()` # these below are nested data and we are bringing in only one row per case. cases_vacc_history_clean <- clean_case_vax_history(                               cases = cases,                               language_tokens = language_tokens)   cases_address_history_clean <- clean_case_address_history(   cases = cases,   locations_clean = locations_clean,   language_tokens = language_tokens)  cases_dateranges_history_clean <- clean_case_med_history(   cases = cases,   language_tokens = language_tokens)  cases_clean <- clean_cases(   cases = cases,   cases_address_history_clean = cases_address_history_clean,   cases_vacc_history_clean = cases_vacc_history_clean,   cases_dateranges_history_clean = cases_dateranges_history_clean,   language_tokens = language_tokens )"},{"path":[]},{"path":"https://joshwlambert.github.io/epipipe/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joshua W. Lambert. Author, maintainer, copyright holder. Sara Hollis. Author, copyright holder. Ed Knock. Author, copyright holder. Anton Camacho. Author, copyright holder. Yurie Izawa. Author, copyright holder.","code":""},{"path":"https://joshwlambert.github.io/epipipe/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lambert J, Hollis S, Knock E, Camacho , Izawa Y (2023). epipipe: Library Epidemiological pipeline chunks form vignettes. R package version 0.1.0, https://joshwlambert.github.io/epipipe/.","code":"@Manual{,   title = {epipipe: Library of Epidemiological pipeline chunks in the form of vignettes},   author = {Joshua W. Lambert and Sara Hollis and Ed Knock and Anton Camacho and Yurie Izawa},   year = {2023},   note = {R package version 0.1.0},   url = {https://joshwlambert.github.io/epipipe/}, }"},{"path":"https://joshwlambert.github.io/epipipe/index.html","id":"epipipe","dir":"","previous_headings":"","what":"Library of Epidemiological pipeline chunks in the form of vignettes","title":"Library of Epidemiological pipeline chunks in the form of vignettes","text":"goal epipipe document build epidemiological pipelines. package contains set vignettes provide explanation reading epidemiological data R, cleaning steps, applying epi-methods data. aim vignettes provide modular chunks explain epidemiological steps help user build custom analysis pipelines copying pasting together examples provide. epipipe provides documents “glue” code links together R packages methods natively interoperable. See Get Started vignette explanation package works vignettes can combined create analysis pipeline. epipipe package complementary resource Epidemiological R Handbook.","code":""},{"path":"https://joshwlambert.github.io/epipipe/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Library of Epidemiological pipeline chunks in the form of vignettes","text":"can install development version epipipe GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"joshwlambert/epipipe\")"},{"path":"https://joshwlambert.github.io/epipipe/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Library of Epidemiological pipeline chunks in the form of vignettes","text":"package still early-stage development, example available yet.","code":""},{"path":"https://joshwlambert.github.io/epipipe/reference/temp_func.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporary function for R folder — temp_func","title":"Temporary function for R folder — temp_func","text":"Temporary function R folder","code":""},{"path":"https://joshwlambert.github.io/epipipe/reference/temp_func.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporary function for R folder — temp_func","text":"","code":"temp_func(x)"},{"path":"https://joshwlambert.github.io/epipipe/reference/temp_func.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporary function for R folder — temp_func","text":"x Variable.","code":""},{"path":"https://joshwlambert.github.io/epipipe/reference/temp_func.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporary function for R folder — temp_func","text":"output, called printing side-effect.","code":""},{"path":"https://joshwlambert.github.io/epipipe/reference/temp_func.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporary function for R folder — temp_func","text":"","code":"temp_func(\"a\") #> [1] \"a\""}]
